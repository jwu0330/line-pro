// 安裝腳本生成器 - 所有內容都在這裡，不需要從網路下載

function generateInstallCommand(extensionId) {
    // 使用字符串拼接而不是模板字串，避免特殊字符問題
    var cmd = '# LINE Opener Pro - 安裝指令（無需網路下載）\n';
    cmd += '$extId = "' + extensionId + '"\n';
    cmd += '$installDir = "$env:LOCALAPPDATA\\LineOpenerPro\\native-host"\n';
    cmd += 'New-Item -ItemType Directory -Path $installDir -Force | Out-Null\n\n';
    
    // line_opener_host.bat
    cmd += '# 建立 line_opener_host.bat\n';
    cmd += 'Set-Content "$installDir\\line_opener_host.bat" -Value @\'\n';
    cmd += '@echo off\n';
    cmd += 'REM Native Messaging Host\n';
    cmd += 'powershell -ExecutionPolicy Bypass -NoProfile -NonInteractive -File "%~dp0line_opener_host.ps1"\n';
    cmd += '\'@ -Encoding ASCII\n\n';
    
    // line_opener_host.ps1
    cmd += '# 建立 line_opener_host.ps1\n';
    cmd += 'Set-Content "$installDir\\line_opener_host.ps1" -Value @\'\n';
    cmd += '$lengthBytes = New-Object byte[] 4\n';
    cmd += '$stdin = [Console]::OpenStandardInput()\n';
    cmd += '$bytesRead = $stdin.Read($lengthBytes, 0, 4)\n';
    cmd += 'if ($bytesRead -eq 0) { exit 0 }\n';
    cmd += '$messageLength = [BitConverter]::ToInt32($lengthBytes, 0)\n';
    cmd += '$messageBytes = New-Object byte[] $messageLength\n';
    cmd += '$stdin.Read($messageBytes, 0, $messageLength) | Out-Null\n';
    cmd += '$messageJson = [System.Text.Encoding]::UTF8.GetString($messageBytes)\n';
    cmd += '$message = $messageJson | ConvertFrom-Json\n';
    cmd += 'if ($message.action -eq \'ping\') {\n';
    cmd += '    $response = @{ success = $true; message = "Native Host is running"; version = "2.3.0" } | ConvertTo-Json -Compress\n';
    cmd += '} elseif ($message.action -eq \'openLINE\') {\n';
    cmd += '    $scriptDir = Split-Path -Parent $MyInvocation.MyCommand.Path\n';
    cmd += '    $autoClickScript = Join-Path $scriptDir "auto_click_line.ps1"\n';
    cmd += '    Start-Process powershell -ArgumentList "-ExecutionPolicy Bypass -WindowStyle Hidden -NoProfile -NonInteractive -File `"$autoClickScript`"" -WindowStyle Hidden\n';
    cmd += '    $response = @{ success = $true; message = "LINE opener triggered" } | ConvertTo-Json -Compress\n';
    cmd += '} else {\n';
    cmd += '    $response = @{ success = $false; error = "Unknown action: $($message.action)" } | ConvertTo-Json -Compress\n';
    cmd += '}\n';
    cmd += '$responseBytes = [System.Text.Encoding]::UTF8.GetBytes($response)\n';
    cmd += '$lengthBytes = [BitConverter]::GetBytes($responseBytes.Length)\n';
    cmd += '$stdout = [Console]::OpenStandardOutput()\n';
    cmd += '$stdout.Write($lengthBytes, 0, 4)\n';
    cmd += '$stdout.Write($responseBytes, 0, $responseBytes.Length)\n';
    cmd += '$stdout.Flush()\n';
    cmd += '\'@ -Encoding UTF8\n\n';
    
    // auto_click_line.ps1 (簡化版)
    cmd += '# 建立 auto_click_line.ps1\n';
    cmd += 'Set-Content "$installDir\\auto_click_line.ps1" -Value @\'\n';
    cmd += '$ErrorActionPreference = "Continue"\n';
    cmd += 'Add-Type -AssemblyName UIAutomationClient\n';
    cmd += 'Add-Type -AssemblyName UIAutomationTypes\n';
    cmd += 'Add-Type -AssemblyName System.Windows.Forms\n';
    cmd += '$edge = Get-Process msedge -ErrorAction SilentlyContinue | Where-Object { $_.MainWindowHandle -ne 0 } | Select-Object -First 1\n';
    cmd += 'if (-not $edge) {\n';
    cmd += '    $edgePath = "$env:ProgramFiles\\Microsoft\\Edge\\Application\\msedge.exe"\n';
    cmd += '    if (-not (Test-Path $edgePath)) { $edgePath = "${env:ProgramFiles(x86)}\\Microsoft\\Edge\\Application\\msedge.exe" }\n';
    cmd += '    Start-Process $edgePath "edge://newtab/"\n';
    cmd += '    Start-Sleep -Seconds 3\n';
    cmd += '    $edge = Get-Process msedge -ErrorAction SilentlyContinue | Where-Object { $_.MainWindowHandle -ne 0 } | Select-Object -First 1\n';
    cmd += '} else {\n';
    cmd += '    $edgePath = "$env:ProgramFiles\\Microsoft\\Edge\\Application\\msedge.exe"\n';
    cmd += '    if (-not (Test-Path $edgePath)) { $edgePath = "${env:ProgramFiles(x86)}\\Microsoft\\Edge\\Application\\msedge.exe" }\n';
    cmd += '    Start-Process $edgePath "edge://newtab/"\n';
    cmd += '    Start-Sleep -Seconds 2\n';
    cmd += '}\n';
    cmd += 'if (-not $edge) { exit 1 }\n';
    cmd += 'Add-Type @"\n';
    cmd += 'using System;\n';
    cmd += 'using System.Runtime.InteropServices;\n';
    cmd += 'public class Win {\n';
    cmd += '    [DllImport("user32.dll")]\n';
    cmd += '    public static extern bool SetForegroundWindow(IntPtr hWnd);\n';
    cmd += '    [DllImport("user32.dll")]\n';
    cmd += '    public static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);\n';
    cmd += '    public const int SW_RESTORE = 9;\n';
    cmd += '}\n';
    cmd += '"@\n';
    cmd += '[Win]::ShowWindow($edge.MainWindowHandle, [Win]::SW_RESTORE) | Out-Null\n';
    cmd += '[Win]::SetForegroundWindow($edge.MainWindowHandle) | Out-Null\n';
    cmd += 'Start-Sleep -Milliseconds 500\n';
    cmd += '$element = [System.Windows.Automation.AutomationElement]::FromHandle($edge.MainWindowHandle)\n';
    cmd += 'if (-not $element) { exit 1 }\n';
    cmd += 'Start-Sleep -Milliseconds 1000\n';
    cmd += '$element = [System.Windows.Automation.AutomationElement]::FromHandle($edge.MainWindowHandle)\n';
    cmd += '$extensionsButton = $null\n';
    cmd += '$nameCondition = New-Object System.Windows.Automation.PropertyCondition([System.Windows.Automation.AutomationElement]::NameProperty, "擴充功能")\n';
    cmd += '$extensionsButton = $element.FindFirst([System.Windows.Automation.TreeScope]::Descendants, $nameCondition)\n';
    cmd += 'if (-not $extensionsButton) {\n';
    cmd += '    $nameCondition = New-Object System.Windows.Automation.PropertyCondition([System.Windows.Automation.AutomationElement]::NameProperty, "Extensions")\n';
    cmd += '    $extensionsButton = $element.FindFirst([System.Windows.Automation.TreeScope]::Descendants, $nameCondition)\n';
    cmd += '}\n';
    cmd += 'if (-not $extensionsButton) {\n';
    cmd += '    $idCondition = New-Object System.Windows.Automation.PropertyCondition([System.Windows.Automation.AutomationElement]::AutomationIdProperty, "view_1015")\n';
    cmd += '    $extensionsButton = $element.FindFirst([System.Windows.Automation.TreeScope]::Descendants, $idCondition)\n';
    cmd += '}\n';
    cmd += '$lineButton = $null\n';
    cmd += 'if (-not $extensionsButton) {\n';
    cmd += '    $lineCondition = New-Object System.Windows.Automation.PropertyCondition([System.Windows.Automation.AutomationElement]::NameProperty, "LINE")\n';
    cmd += '    $lineButton = $element.FindFirst([System.Windows.Automation.TreeScope]::Descendants, $lineCondition)\n';
    cmd += '    if (-not $lineButton) { exit 1 }\n';
    cmd += '} else {\n';
    cmd += '    $clicked = $false\n';
    cmd += '    try {\n';
    cmd += '        $invokePattern = $extensionsButton.GetCurrentPattern([System.Windows.Automation.InvokePattern]::Pattern)\n';
    cmd += '        if ($invokePattern) { $invokePattern.Invoke(); $clicked = $true }\n';
    cmd += '    } catch {}\n';
    cmd += '    if (-not $clicked) {\n';
    cmd += '        try {\n';
    cmd += '            $togglePattern = $extensionsButton.GetCurrentPattern([System.Windows.Automation.TogglePattern]::Pattern)\n';
    cmd += '            if ($togglePattern) { $togglePattern.Toggle(); $clicked = $true }\n';
    cmd += '        } catch {}\n';
    cmd += '    }\n';
    cmd += '    if (-not $clicked) {\n';
    cmd += '        try {\n';
    cmd += '            $expandPattern = $extensionsButton.GetCurrentPattern([System.Windows.Automation.ExpandCollapsePattern]::Pattern)\n';
    cmd += '            if ($expandPattern) { $expandPattern.Expand(); $clicked = $true }\n';
    cmd += '        } catch {}\n';
    cmd += '    }\n';
    cmd += '    if (-not $clicked) {\n';
    cmd += '        try {\n';
    cmd += '            $extensionsButton.SetFocus()\n';
    cmd += '            Start-Sleep -Milliseconds 100\n';
    cmd += '            [System.Windows.Forms.SendKeys]::SendWait("{ENTER}")\n';
    cmd += '            $clicked = $true\n';
    cmd += '        } catch { exit 1 }\n';
    cmd += '    }\n';
    cmd += '    Start-Sleep -Milliseconds 800\n';
    cmd += '    $element = [System.Windows.Automation.AutomationElement]::FromHandle($edge.MainWindowHandle)\n';
    cmd += '    $lineCondition = New-Object System.Windows.Automation.PropertyCondition([System.Windows.Automation.AutomationElement]::NameProperty, "LINE")\n';
    cmd += '    $lineButton = $element.FindFirst([System.Windows.Automation.TreeScope]::Descendants, $lineCondition)\n';
    cmd += '    if (-not $lineButton) { exit 1 }\n';
    cmd += '}\n';
    cmd += '$success = $false\n';
    cmd += 'try {\n';
    cmd += '    $invokePattern = $lineButton.GetCurrentPattern([System.Windows.Automation.InvokePattern]::Pattern)\n';
    cmd += '    if ($invokePattern) { $invokePattern.Invoke(); $success = $true }\n';
    cmd += '} catch {}\n';
    cmd += 'if (-not $success) {\n';
    cmd += '    try {\n';
    cmd += '        $togglePattern = $lineButton.GetCurrentPattern([System.Windows.Automation.TogglePattern]::Pattern)\n';
    cmd += '        if ($togglePattern) { $togglePattern.Toggle(); $success = $true }\n';
    cmd += '    } catch {}\n';
    cmd += '}\n';
    cmd += 'if (-not $success) {\n';
    cmd += '    try {\n';
    cmd += '        $expandPattern = $lineButton.GetCurrentPattern([System.Windows.Automation.ExpandCollapsePattern]::Pattern)\n';
    cmd += '        if ($expandPattern) { $expandPattern.Expand(); $success = $true }\n';
    cmd += '    } catch {}\n';
    cmd += '}\n';
    cmd += 'if (-not $success) {\n';
    cmd += '    try {\n';
    cmd += '        $lineButton.SetFocus()\n';
    cmd += '        Start-Sleep -Milliseconds 100\n';
    cmd += '        [System.Windows.Forms.SendKeys]::SendWait("{ENTER}")\n';
    cmd += '        $success = $true\n';
    cmd += '    } catch {}\n';
    cmd += '}\n';
    cmd += 'if ($success) {\n';
    cmd += '    Start-Sleep -Seconds 3\n';
    cmd += '    try {\n';
    cmd += '        $originalEdgeHandle = $edge.MainWindowHandle\n';
    cmd += '        Add-Type @"\n';
    cmd += 'using System;\n';
    cmd += 'using System.Runtime.InteropServices;\n';
    cmd += 'using System.Text;\n';
    cmd += 'public class WindowHelper {\n';
    cmd += '    [DllImport(\\"user32.dll\\")]\n';
    cmd += '    public static extern bool EnumWindows(EnumWindowsProc enumProc, IntPtr lParam);\n';
    cmd += '    [DllImport(\\"user32.dll\\")]\n';
    cmd += '    public static extern int GetWindowText(IntPtr hWnd, StringBuilder lpString, int nMaxCount);\n';
    cmd += '    [DllImport(\\"user32.dll\\")]\n';
    cmd += '    public static extern bool IsWindowVisible(IntPtr hWnd);\n';
    cmd += '    [DllImport(\\"user32.dll\\")]\n';
    cmd += '    public static extern uint GetWindowThreadProcessId(IntPtr hWnd, out uint lpdwProcessId);\n';
    cmd += '    [DllImport(\\"user32.dll\\")]\n';
    cmd += '    public static extern bool PostMessage(IntPtr hWnd, uint Msg, IntPtr wParam, IntPtr lParam);\n';
    cmd += '    public delegate bool EnumWindowsProc(IntPtr hWnd, IntPtr lParam);\n';
    cmd += '    public const uint WM_CLOSE = 0x0010;\n';
    cmd += '}\n';
    cmd += '"@\n';
    cmd += '        $edgeWindows = New-Object System.Collections.ArrayList\n';
    cmd += '        $callback = {\n';
    cmd += '            param($hwnd, $lParam)\n';
    cmd += '            if ([WindowHelper]::IsWindowVisible($hwnd)) {\n';
    cmd += '                $winProcessId = 0\n';
    cmd += '                [WindowHelper]::GetWindowThreadProcessId($hwnd, [ref]$winProcessId) | Out-Null\n';
    cmd += '                if ($winProcessId -eq $edge.Id) {\n';
    cmd += '                    $title = New-Object System.Text.StringBuilder 256\n';
    cmd += '                    [WindowHelper]::GetWindowText($hwnd, $title, 256) | Out-Null\n';
    cmd += '                    $titleStr = $title.ToString()\n';
    cmd += '                    if ($titleStr -notmatch "LINE") {\n';
    cmd += '                        $edgeWindows.Add(@{Handle=$hwnd; Title=$titleStr}) | Out-Null\n';
    cmd += '                    }\n';
    cmd += '                }\n';
    cmd += '            }\n';
    cmd += '            return $true\n';
    cmd += '        }\n';
    cmd += '        [WindowHelper]::EnumWindows($callback, [IntPtr]::Zero)\n';
    cmd += '        foreach ($window in $edgeWindows) {\n';
    cmd += '            [WindowHelper]::PostMessage($window.Handle, [WindowHelper]::WM_CLOSE, [IntPtr]::Zero, [IntPtr]::Zero) | Out-Null\n';
    cmd += '        }\n';
    cmd += '    } catch {}\n';
    cmd += '    exit 0\n';
    cmd += '}\n';
    cmd += 'exit 1\n';
    cmd += '\'@ -Encoding UTF8\n\n';
    
    // manifest
    cmd += '# 建立 manifest\n';
    cmd += '$hostPath = "$installDir\\line_opener_host.bat" -replace \'\\\\\', \'\\\\\\\\\'\n';
    cmd += '$manifest = @"\n';
    cmd += '{\n';
    cmd += '  "name": "com.line.opener",\n';
    cmd += '  "description": "LINE Opener Native Host",\n';
    cmd += '  "path": "$hostPath",\n';
    cmd += '  "type": "stdio",\n';
    cmd += '  "allowed_origins": [\n';
    cmd += '    "chrome-extension://$extId/"\n';
    cmd += '  ]\n';
    cmd += '}\n';
    cmd += '"@\n';
    cmd += 'Set-Content "$installDir\\com.line.opener.json" -Value $manifest -Encoding UTF8\n\n';
    
    // 註冊
    cmd += '# 註冊到 Chrome\n';
    cmd += 'reg add "HKCU\\Software\\Google\\Chrome\\NativeMessagingHosts\\com.line.opener" /ve /t REG_SZ /d "$installDir\\com.line.opener.json" /f | Out-Null\n\n';
    
    cmd += 'Write-Host "安裝完成！" -ForegroundColor Green\n';
    cmd += 'Write-Host "請回到 Chrome 點擊擴充圖示，然後點擊『重新檢測』" -ForegroundColor Cyan';
    
    return cmd;
}
